-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package wave
@version 0.1.0.0

module JS.Ast
type Var = Text
type Record a = Map Var a
data Lit
LInt :: Int -> Lit
LBool :: Bool -> Lit
LFloat :: Float -> Lit
LString :: Text -> Lit
data Statement
SExpr :: Expr -> Statement
SRet :: Expr -> Statement
SDef :: Definition -> Statement
SIf :: Expr -> Sub -> Statement
type Sub = [Statement]
data Expr
ELit :: Lit -> Expr
EVar :: Var -> Expr
EFun :: [Var] -> Sub -> Expr
EFunCall :: Expr -> [Expr] -> Expr
ERecord :: Record Expr -> Expr
EAnd :: [Expr] -> Expr
EEqual :: Expr -> Expr -> Expr
ERecordAccess :: Expr -> Label -> Expr
EBinOp :: Text -> Expr -> Expr -> Expr
ERaw :: Text -> Expr
type Label = Text
data Definition
Variable :: Var -> Expr -> Definition
Function :: Var -> [Var] -> Sub -> Definition
newtype File
File :: [Statement] -> File
instance GHC.Classes.Eq JS.Ast.Lit
instance GHC.Show.Show JS.Ast.Lit
instance GHC.Classes.Eq JS.Ast.Statement
instance GHC.Show.Show JS.Ast.Statement
instance GHC.Classes.Eq JS.Ast.Expr
instance GHC.Show.Show JS.Ast.Expr
instance GHC.Classes.Eq JS.Ast.Definition
instance GHC.Show.Show JS.Ast.Definition
instance GHC.Classes.Eq JS.Ast.File
instance GHC.Show.Show JS.Ast.File

module JS.Pretty
pp :: (a -> Doc ann) -> a -> Text
render :: Doc a -> Text
ppFile :: File -> Doc a
ppRecord :: (a -> Doc ann) -> Record a -> Doc ann
ppLit :: Lit -> Doc a
ppSub :: Sub -> Doc a
ppDef :: Definition -> Doc a
ppStatement :: Statement -> Doc a
ppExpr :: Expr -> Doc a
isSimpleExpr :: Expr -> Bool

module Wave.Common
type TypeVar = Text
type TypeCon = Text
type Label = Text
type Constr = Text
type Record a = Map Label a
data Variant a
Variant :: Constr -> a -> Variant a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wave.Common.Variant a)
instance GHC.Show.Show a => GHC.Show.Show (Wave.Common.Variant a)

module Wave.Types
data Type
TypeVar :: TypeVar -> Type
TypeCon :: TypeCon -> Type
TypeApp :: Type -> Type -> Type
TypeFun :: [Type] -> Type -> Type
TypeRec :: [(Label, Type)] -> Type
instance GHC.Classes.Eq Wave.Types.Type
instance GHC.Show.Show Wave.Types.Type

module Wave.Ast
type Var = Text
data Lit
LInt :: Int -> Lit
LFloat :: Float -> Lit
LString :: Text -> Lit
data Expr
ELit :: Lit -> Expr
EVar :: Var -> Expr
EFun :: [Var] -> Sub -> Expr
EFunCall :: Expr -> [Expr] -> Expr
ERecord :: Record Expr -> Expr
EFfi :: Text -> [Expr] -> Expr
EVariant :: Variant Expr -> Expr
ECase :: Expr -> [(Pattern, Expr)] -> Expr
ERecordAccess :: Expr -> Label -> Expr
data DataType
DataType :: Constr -> [TypeVar] -> [Variant Type] -> DataType
data Definition
TypeDef :: DataType -> Definition
TermDef :: TermDef -> Definition
data TermDef
Variable :: Var -> Expr -> TermDef
Function :: Var -> [Var] -> Sub -> TermDef
data Statement
SExpr :: Expr -> Statement
SDef :: TermDef -> Statement
type Sub = [Statement]
data Pattern
PWildcard :: Pattern
PVar :: Var -> Pattern
PLit :: Lit -> Pattern
PRecord :: Record Pattern -> Pattern
PVariant :: Variant Pattern -> Pattern
newtype File
File :: [Definition] -> File
instance GHC.Classes.Eq Wave.Ast.Lit
instance GHC.Show.Show Wave.Ast.Lit
instance GHC.Classes.Eq Wave.Ast.DataType
instance GHC.Show.Show Wave.Ast.DataType
instance GHC.Classes.Eq Wave.Ast.Pattern
instance GHC.Show.Show Wave.Ast.Pattern
instance GHC.Classes.Eq Wave.Ast.TermDef
instance GHC.Show.Show Wave.Ast.TermDef
instance GHC.Classes.Eq Wave.Ast.Statement
instance GHC.Show.Show Wave.Ast.Statement
instance GHC.Classes.Eq Wave.Ast.Expr
instance GHC.Show.Show Wave.Ast.Expr
instance GHC.Classes.Eq Wave.Ast.Definition
instance GHC.Show.Show Wave.Ast.Definition
instance GHC.Classes.Eq Wave.Ast.File
instance GHC.Show.Show Wave.Ast.File

module Wave.Builtins
type Builtins = Map Var Builtin
data Builtin
Builtin :: Var -> Type -> Impl -> Builtin
[bName] :: Builtin -> Var
[bType] :: Builtin -> Type
[bImpl] :: Builtin -> Impl
data Impl
Fun :: Text -> Impl
BinOp :: Text -> Impl
builtinFun :: Var -> Type -> Text -> (Var, Builtin)
builtinBinOp :: Var -> Type -> Text -> (Var, Builtin)
builtin :: (Text -> Impl) -> Var -> Type -> Text -> (Var, Builtin)
builtins :: Builtins
ints :: Builtins
unit :: Expr
true :: Expr
false :: Expr
tUnit :: Type
tInt :: Type
tFloat :: Type
tString :: Type
tBool :: Type

module PatternMatching
data PatResult
PatResult :: [Expr] -> [(Var, Expr)] -> PatResult
[conditions] :: PatResult -> [Expr]
[matchers] :: PatResult -> [(Var, Expr)]
instance GHC.Base.Semigroup PatternMatching.PatResult
instance GHC.Base.Monoid PatternMatching.PatResult

module Translate
type TransState = Int
type TransReader = Builtins
type Translate a = (MonadState TransState a, MonadReader Builtins a)
translate :: (a -> StateT TransState (Reader Builtins) b) -> Builtins -> a -> b
genVar :: Translate m => Text -> m Var
translateFile :: Translate m => File -> m File
translateDef :: Translate m => TermDef -> m Definition
translateExpr :: Translate m => Expr -> m Expr
translatePatterns :: Translate m => Expr -> [(Pattern, Expr)] -> m Sub
translatePattern :: Translate m => Expr -> Pattern -> m PatResult
translateSub :: Translate m => Sub -> m Sub
translateStatement :: Translate m => Statement -> m Statement
translateLit :: Lit -> Lit

module Compile
compile :: File -> Text
