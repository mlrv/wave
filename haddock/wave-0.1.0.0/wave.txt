-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package wave
@version 0.1.0.0

module JS.Ast
type Var = Text
type Record a = Map Var a
data Lit
LInt :: Int -> Lit
LBool :: Bool -> Lit
LFloat :: Float -> Lit
LString :: Text -> Lit
data Statement
SExpr :: Expr -> Statement
SRet :: Expr -> Statement
SDef :: Definition -> Statement
SIf :: Expr -> Sub -> Statement
type Sub = [Statement]
data Expr
ELit :: Lit -> Expr
EVar :: Var -> Expr
EFun :: [Var] -> Sub -> Expr
EFunCall :: Expr -> [Expr] -> Expr
ERecord :: Record Expr -> Expr
EAnd :: [Expr] -> Expr
EEqual :: Expr -> Expr -> Expr
ERecordAccess :: Expr -> Label -> Expr
type Label = Text
data Definition
Variable :: Var -> Expr -> Definition
Function :: Var -> [Var] -> Sub -> Definition
newtype File
File :: [Statement] -> File
instance GHC.Classes.Eq JS.Ast.Lit
instance GHC.Show.Show JS.Ast.Lit
instance GHC.Classes.Eq JS.Ast.Statement
instance GHC.Show.Show JS.Ast.Statement
instance GHC.Classes.Eq JS.Ast.Expr
instance GHC.Show.Show JS.Ast.Expr
instance GHC.Classes.Eq JS.Ast.Definition
instance GHC.Show.Show JS.Ast.Definition
instance GHC.Classes.Eq JS.Ast.File
instance GHC.Show.Show JS.Ast.File

module JS.Pretty
pp :: (a -> Doc ann) -> a -> Text
render :: Doc a -> Text
ppFile :: File -> Doc a
ppRecord :: (a -> Doc ann) -> Record a -> Doc ann
ppLit :: Lit -> Doc a
ppSub :: Sub -> Doc a
ppDef :: Definition -> Doc a
ppStatement :: Statement -> Doc a
ppExpr :: Expr -> Doc a
isSimpleExpr :: Expr -> Bool

module Wave.Ast
type Var = Text
type Record a = Map Var a
data Lit
LInt :: Int -> Lit
LFloat :: Float -> Lit
LString :: Text -> Lit
data Statement
SExpr :: Expr -> Statement
SDef :: Definition -> Statement
type Sub = [Statement]
data Pattern
PWildcard :: Pattern
PVar :: Var -> Pattern
PLit :: Lit -> Pattern
PRecord :: Record Pattern -> Pattern
PVariant :: Text -> Pattern -> Pattern
data Expr
ELit :: Lit -> Expr
EVar :: Var -> Expr
EFun :: [Var] -> Sub -> Expr
EFunCall :: Expr -> [Expr] -> Expr
ERecord :: Record Expr -> Expr
EFfi :: Text -> [Expr] -> Expr
EVariant :: Text -> Expr -> Expr
ECase :: Expr -> [(Pattern, Expr)] -> Expr
ERecordAccess :: Expr -> Label -> Expr
type Label = Text
data Definition
Variable :: Var -> Expr -> Definition
Function :: Var -> [Var] -> Sub -> Definition
newtype File
File :: [Definition] -> File
instance GHC.Classes.Eq Wave.Ast.Lit
instance GHC.Show.Show Wave.Ast.Lit
instance GHC.Classes.Eq Wave.Ast.Pattern
instance GHC.Show.Show Wave.Ast.Pattern
instance GHC.Classes.Eq Wave.Ast.Statement
instance GHC.Show.Show Wave.Ast.Statement
instance GHC.Classes.Eq Wave.Ast.Expr
instance GHC.Show.Show Wave.Ast.Expr
instance GHC.Classes.Eq Wave.Ast.Definition
instance GHC.Show.Show Wave.Ast.Definition
instance GHC.Classes.Eq Wave.Ast.File
instance GHC.Show.Show Wave.Ast.File

module Translate
type TransState = Int
type Translate a = MonadState TransState a
translate :: (a -> State TransState b) -> a -> b
genVar :: Translate m => Text -> m Var
translateFile :: Translate m => File -> m File
translateDef :: Translate m => Definition -> m Definition
translateExpr :: Translate m => Expr -> m Expr
data PatResult
PatResult :: [Expr] -> [(Var, Expr)] -> PatResult
[conditions] :: PatResult -> [Expr]
[matchers] :: PatResult -> [(Var, Expr)]
translatePatterns :: Translate m => Expr -> [(Pattern, Expr)] -> m Sub
translatePattern :: Translate m => Expr -> Pattern -> m PatResult
translateLit :: Lit -> Lit
translateSub :: Translate m => Sub -> m Sub
translateStatement :: Translate m => Statement -> m Statement
instance GHC.Base.Semigroup Translate.PatResult
instance GHC.Base.Monoid Translate.PatResult

module Compile
compile :: File -> Text
