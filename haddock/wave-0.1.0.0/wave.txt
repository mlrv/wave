-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package wave
@version 0.1.0.0

module JS.Ast
type Var = Text
type Record a = Map Var a
data Lit
LInt :: Int -> Lit
LBool :: Bool -> Lit
LFloat :: Float -> Lit
LString :: Text -> Lit
data Statement
SExpr :: Expr -> Statement
SRet :: Expr -> Statement
SDef :: Definition -> Statement
SIf :: Expr -> Sub -> Statement
type Sub = [Statement]
data Expr
ELit :: Lit -> Expr
EVar :: Var -> Expr
EFun :: [Var] -> Sub -> Expr
EFunCall :: Expr -> [Expr] -> Expr
ERecord :: Record Expr -> Expr
EAnd :: [Expr] -> Expr
EEqual :: Expr -> Expr -> Expr
ERecordAccess :: Expr -> Label -> Expr
EBinOp :: Text -> Expr -> Expr -> Expr
ERaw :: Text -> Expr
type Label = Text
data Definition
Variable :: Var -> Expr -> Definition
Function :: Var -> [Var] -> Sub -> Definition
newtype File
File :: [Statement] -> File
instance GHC.Classes.Eq JS.Ast.Lit
instance GHC.Show.Show JS.Ast.Lit
instance GHC.Classes.Eq JS.Ast.Statement
instance GHC.Show.Show JS.Ast.Statement
instance GHC.Classes.Eq JS.Ast.Expr
instance GHC.Show.Show JS.Ast.Expr
instance GHC.Classes.Eq JS.Ast.Definition
instance GHC.Show.Show JS.Ast.Definition
instance GHC.Classes.Eq JS.Ast.File
instance GHC.Show.Show JS.Ast.File

module JS.Pretty
pp :: (a -> Doc ann) -> a -> Text
render :: Doc a -> Text
ppFile :: File -> Doc a
ppRecord :: (a -> Doc ann) -> Record a -> Doc ann
ppLit :: Lit -> Doc a
ppSub :: Sub -> Doc a
ppDef :: Definition -> Doc a
ppStatement :: Statement -> Doc a
ppExpr :: Expr -> Doc a
isSimpleExpr :: Expr -> Bool

module Wave.Common
type TypeVar = Text
type TypeCon = Text
type Label = Text
type Constr = Text
type Record a = Map Label a
data Variant a
Variant :: Constr -> a -> Variant a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wave.Common.Variant a)
instance GHC.Show.Show a => GHC.Show.Show (Wave.Common.Variant a)

module Wave.Types
data Type
TypeVar :: TypeVar -> Type
TypeCon :: TypeCon -> Type
TypeApp :: Type -> Type -> Type
TypeFun :: [Type] -> Type -> Type
TypeRec :: [(Label, Type)] -> Type
instance GHC.Classes.Eq Wave.Types.Type
instance GHC.Show.Show Wave.Types.Type

module Wave.Ast
type Var = Text
data Lit
LInt :: Int -> Lit
LFloat :: Float -> Lit
LString :: Text -> Lit
data Expr a
EAnnotated :: a -> Expr a -> Expr a
ELit :: Lit -> Expr a
EVar :: Var -> Expr a
EFun :: [Var] -> Sub a -> Expr a
EFunCall :: Expr a -> [Expr a] -> Expr a
ERecord :: Record (Expr a) -> Expr a
EFfi :: Text -> [Expr a] -> Expr a
EVariant :: Variant (Expr a) -> Expr a
ECase :: Expr a -> [(Pattern, Expr a)] -> Expr a
ERecordAccess :: Expr a -> Label -> Expr a
data DataType
DataType :: Constr -> [TypeVar] -> [Variant Type] -> DataType
data Definition a
TypeDef :: DataType -> Definition a
TermDef :: TermDef a -> Definition a
data TermDef a
Variable :: Var -> Expr a -> TermDef a
Function :: Var -> [Var] -> Sub a -> TermDef a
data Statement a
SExpr :: Expr a -> Statement a
SDef :: TermDef a -> Statement a
type Sub a = [Statement a]
data Pattern
PWildcard :: Pattern
PVar :: Var -> Pattern
PLit :: Lit -> Pattern
PRecord :: Record Pattern -> Pattern
PVariant :: Variant Pattern -> Pattern
newtype File a
File :: [Definition a] -> File a
instance GHC.Classes.Eq Wave.Ast.Lit
instance GHC.Show.Show Wave.Ast.Lit
instance GHC.Classes.Eq Wave.Ast.DataType
instance GHC.Show.Show Wave.Ast.DataType
instance GHC.Classes.Eq Wave.Ast.Pattern
instance GHC.Show.Show Wave.Ast.Pattern
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wave.Ast.TermDef a)
instance GHC.Show.Show a => GHC.Show.Show (Wave.Ast.TermDef a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wave.Ast.Statement a)
instance GHC.Show.Show a => GHC.Show.Show (Wave.Ast.Statement a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wave.Ast.Expr a)
instance GHC.Show.Show a => GHC.Show.Show (Wave.Ast.Expr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wave.Ast.Definition a)
instance GHC.Show.Show a => GHC.Show.Show (Wave.Ast.Definition a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wave.Ast.File a)
instance GHC.Show.Show a => GHC.Show.Show (Wave.Ast.File a)

module Wave.Parser
type Parser = Parsec Void Text
type Ann = SourcePos
runParser :: Parser a -> FilePath -> Text -> Either Text a
parseLit :: Parser Lit
sc :: Parser ()
lexeme :: Parser a -> Parser a
symbol :: Text -> Parser ()
stringLiteral :: Parser Text
numberLiteral :: Parser Lit
getAnn :: Parser Ann

module Wave.Builtins
type Builtins = Map Var Builtin
data Builtin
Builtin :: Var -> Type -> Impl -> Builtin
[bName] :: Builtin -> Var
[bType] :: Builtin -> Type
[bImpl] :: Builtin -> Impl
data Impl
Fun :: Text -> Impl
BinOp :: Text -> Impl
builtinFun :: Var -> Type -> Text -> (Var, Builtin)
builtinBinOp :: Var -> Type -> Text -> (Var, Builtin)
builtin :: (Text -> Impl) -> Var -> Type -> Text -> (Var, Builtin)
builtins :: Builtins
ints :: Builtins
strings :: Builtins
bools :: Builtins
unit :: Expr ()
true :: Expr ()
false :: Expr ()
tUnit :: Type
tInt :: Type
tFloat :: Type
tString :: Type
tBool :: Type
bool :: DataType
maybe :: DataType

module PatternMatching
data PatResult
PatResult :: [Expr] -> [(Var, Expr)] -> PatResult
[conditions] :: PatResult -> [Expr]
[matchers] :: PatResult -> [(Var, Expr)]
instance GHC.Base.Semigroup PatternMatching.PatResult
instance GHC.Base.Monoid PatternMatching.PatResult

module Translate
type TransState = Int
type TransReader = Builtins
type Translate a = (MonadState TransState a, MonadReader Builtins a)
translate :: (a -> StateT TransState (Reader Builtins) b) -> Builtins -> a -> b
genVar :: Translate m => Text -> m Var
translateFile :: Translate m => File () -> m File
translateDef :: Translate m => TermDef () -> m Definition
translateExpr :: Translate m => Expr () -> m Expr
translatePatterns :: Translate m => Expr -> [(Pattern, Expr ())] -> m Sub
translatePattern :: Translate m => Expr -> Pattern -> m PatResult
translateSub :: Translate m => Sub () -> m Sub
translateStatement :: Translate m => Statement () -> m Statement
translateLit :: Lit -> Lit

module Examples
lit :: File ()
variant :: File ()
patmatch1 :: File ()
patmatch2 :: File ()
patmatch3 :: File ()
patmatch4 :: File ()
patmatch5 :: File ()
exprToFile :: Expr () -> File ()

module Compile
compile :: File () -> Text
